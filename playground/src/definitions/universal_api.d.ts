// Generated by dts-bundle-generator v9.3.1

declare module '@caxperts/universal.api' {
    // Generated by dts-bundle-generator v9.3.1

    /**
     * @deprecated
     * Old UPV Target codes
     */
    export declare enum TargetEnum {
        Undefined = "0",
        ThreeD = "1",
        Intelli = "10",
        Browser = "11"
    }
    /**
     * how Queries will be combined
     */
    export declare enum CombineModes {
        And = "AND",
        Or = "OR"
    }
    /**
     * The sceneType defines what this scene contains
     */
    export declare enum SceneType {
        Undefined = "0",
        ThreeD = "1",
        IntelliPid = "10",
        Browser = "11"
    }
    export declare enum UpdateModes {
        Append = 0,
        Full = 1
    }
    export declare enum CustomAttributeDataType {
        Calculation = 0,
        CodeList = 1,
        FreeText = 2,
        Numeric = 3,
        Unknown = 4,
        Color = 5
    }
    export declare enum FeatureTypes {
        Unknown = "Unknown",
        Model = "Model",
        Sketch = "Sketch",
        Markup = "Markup",
        IntellipidSketch = "IntellipidSketch",
        AnimationConfiguration = "AnimationConfiguration",
        AnimationDefinition = "AnimationDefinition",
        Catalogue = "Catalogue",
        Symbol = "Symbol",
        MarkupContainer = "MarkupContainer",
        Orm = "Orm",
        Spraying = "Spraying",
        Comment = "Comment",
        View = "View",
        Package = "Package",
        Folder = "Folder",
        CommentSvg = "CommentSvg",
        Screenshot = "Screenshot",
        Photo = "Photo",
        TwoDToThreeD = "TwoDToThreeD",
        PointOfInterest = "PointOfInterest",
        Drawing = "Drawing",
        Files = "Files",
        MeasurementSnapshot = "MeasurementSnapshot",
        IntelliPidLegendPositions = "IntelliPidLegendPositions",
        IsolationPlan = "IsolationPlan",
        CataloguePlacement = "CataloguePlacement",
        DrawingComment = "DrawingComment",
        AppControl = "AppControl",
        Animation = "Animation",
        PIDSketch = "PIDSketch",
        Report = "Report"
    }
    export declare enum ProjectionSphereType {
        Picture = 0,
        Panorama = 1
    }
    /**
     * @internal
     */
    export declare enum ApiCommands {
        SetCameraView = "SetCameraView",
        GetCameraView = "GetCameraView",
        SetClippingPlane = "SetClippingPlane",
        SetCameraViewLookAtTarget = "SetCameraViewLookAtTarget",
        ResetView = "ResetView",
        GetObjects = "GetObjects",
        GetSelectedObjects = "GetSelectedObjects",
        GetObjectsAttributes = "GetObjectsAttributes",
        GetObjectsBoundingBox = "GetObjectsBoundingBox",
        GetObjectsColors = "GetObjectsColors",
        GetObjectsSnapInfo = "GetObjectsSnapInfo",
        Select = "Select",
        ClearSelection = "ClearSelection",
        Fit = "Fit",
        Color = "Color",
        ClearColor = "ClearColor",
        Highlight = "Highlight",
        ClearHighlight = "ClearHighlight",
        ShowOnly = "ShowOnly",
        SetVisibility = "SetVisibility",
        GetClippingInfo = "GetClippingInfo",
        VolumeClip = "VolumeClip",
        VolumeClipByCoordinates = "VolumeClipByCoordinates",
        IntelliClip = "IntelliClip",
        ClearClipping = "ClearClipping",
        SearchFallback = "SearchFallback",
        PlaceObj = "PlaceObj",
        DrawLine = "DrawLine",
        PlaceText = "PlaceText",
        PlaceArc = "PlaceArc",
        PlacePly = "PlacePly",
        DestroyDrawing = "DestroyDrawing",
        GetModelInfo = "GetModelInfo",
        GetProjectInfo = "GetProjectInfo",
        LoadConfigFile = "LoadConfigFile",
        ClearCustomAttributes = "ClearCustomAttributes",
        ImportCustomAttributeChangeSet = "ImportCustomAttributeChangeset",
        LoadCustomAttributeConfigurationFile = "LoadCustomAttributeConfigurationFile",
        LoadCustomAttributeDataFile = "LoadCustomAttributeDataFile",
        SetCustomAttributeConfiguration = "SetCustomAttributeConfiguration",
        GetCustomAttributeConfiguration = "GetCustomAttributeConfiguration",
        ExportCustomAttributes = "ExportCustomAttributes",
        GetIntelliPidDrawings = "GetIntelliPidDrawings",
        OpenIntelliPidDrawings = "OpenIntelliPidDrawings",
        GetProjectionSpheres = "GetProjectionSpheres",
        GetCurrentProjectionSphere = "GetCurrentProjectionSphere",
        EnterProjectionSphere = "EnterProjectionSphere",
        LeaveProjectionSphere = "LeaveProjectionSphere",
        TakeScreenshot = "TakeScreenshot",
        TakeAndSaveScreenShot = "TakeAndSaveScreenshot",
        GetTreeConfiguration = "GetTreeConfiguration",
        SetTreeConfiguration = "SetTreeConfiguration",
        GetVisibleAspects = "GetVisibleAspects",
        SetVisibleAspects = "SetVisibleAspects",
        LoadColorFile = "LoadColorFile",
        LoadLinkFile = "LoadLinkFile",
        ClearLinks = "ClearLinks",
        FilesTreeDeleteObject = "FilesTreeDeleteObject",
        GetFilesTreeChildren = "GetFilesTreeChildren",
        GetFilesTreeSiblings = "GetFilesTreeSiblings",
        FilesTreeMoveObject = "FilesTreeMoveObject",
        GetFilesTreeRoot = "GetFilesTreeRoot",
        FilesTreeCreateFolder = "FilesTreeCreateFolder",
        PlacePoi = "PlacePoi",
        PlacePoiWithComment = "PlacePoiWithComment",
        AddEventCallback = "AddEventCallback",
        RemoveEventCallback = "RemoveEventCallback",
        GetLifeCycleState = "GetLifeCycleState",
        ShowMessage = "ShowMessage",
        FocusViewer = "FocusViewer",
        QuitApplication = "QuitApplication",
        CacheModel = "CacheModel",
        LoadModel = "LoadModel",
        DeleteModel = "DeleteModel",
        ActivateLicense = "ActivateLicense",
        DeactivateLicense = "DeactivateLicense",
        LoadFile = "LoadFile",
        ProcessFile = "ProcessFile",
        LoadSketch = "LoadSketch",
        LoadPackageFile = "LoadPackageFile",
        ExportPackageFile = "ExportPackageFile",
        ClearAuthConfig = "ClearAuthConfig",
        SetAuthConfig = "SetAuthConfig",
        OpenPath = "OpenPath",
        GetTreeRootNode = "GetTreeRootNode",
        GetTreeFolderChildren = "GetTreeFolderChildren",
        GetTreeFolderSiblings = "GetTreeFolderSiblings",
        GetTreeNodesOfFolder = "GetTreeNodesOfFolder",
        GetTreeStructure = "GetTreeStructure",
        Auth = "Auth",
        LoadOrm = "LoadOrm",
        GetMessageCallback = "GetMessageCallback",
        SetLobsterVisionCameraView = "SetLobsterVisionCameraView",
        LobsterVisionOverlayImage = "LobsterVisionOverlayImage",
        LobsterVisionSetImageOpacity = "LobsterVisionSetImageOpacity",
        LobsterVisionReleaseImage = "LobsterVisionReleaseImage",
        BlockForStreamingClient = "BlockForStreamingClient",
        WfsLogin = "WfsLogin",
        WfsOpenTicket = "WfsOpenTicket",
        WfsLoadRemote = "WfsLoadRemote",
        GetWfsRemoteContent = "GetWfsRemoteContent",
        GetRenderStreamingInfo = "GetRenderStreamingInfo",
        TenForceSetAuth = "TenForceSetAuth",
        TenForceCreateIsolationPlan = "TenForceCreateIsolationPlan",
        TenForceOpenIsolationPlan = "TenForceOpenIsolationPlan",
        TecnimontGetComments = "TecnimontGetComments",
        TecnimontFocusComment = "TecnimontFocusComment",
        FilesTreeImportContainer = "FilesTreeImportContainer",
        GetFilesTreeContent = "GetFilesTreeContent",
        FilesTreeGetContainer = "FilesTreeGetContainer"
    }
    export declare enum PackageConditionTypes {
        None = "None",
        IntelliVolume = "IntelliVolume",
        Group = "Group",
        Attribute = "Attribute",
        Volume = "Volume"
    }
    export declare enum ConsolidationMode {
        Base = "Base",
        AndNot = "AndNot",
        Or = "Or",
        And = "And"
    }
    export declare enum AttributeConditionComparison {
        Equals = "==",
        NotEquals = "!=",
        Like = "Like",
        NotLike = "NotLike"
    }
    export declare enum VolumeConditionMode {
        Includes = "Includes",
        Overlaps = "Overlaps",
        NotIncludes = "Not Includes",
        NotOverlaps = "Not Overlaps"
    }
    export declare enum PointOfInterestType {
        Sphere = 0,
        CustomMesh = 1
    }
    export declare enum ClippingMode {
        None = 0,
        Volume = 1,
        GridMeasure = 2,
        Intelli = 3
    }
    export declare class Vector2D {
        X: number;
        Y: number;
        constructor(X: number, Y: number);
    }
    export declare class Vector3D {
        X: number;
        Y: number;
        Z: number;
        constructor(X: number, Y: number, Z: number);
    }
    export declare class Vector4D {
        X: number;
        Y: number;
        Z: number;
        W: number;
        constructor(X: number, Y: number, Z: number, W: number);
    }
    export declare class CameraView {
        Position: Vector3D;
        Rotation: Vector3D;
        constructor(Position: Vector3D, Rotation: Vector3D);
    }
    export declare class Bounds {
        Min: Vector3D;
        Max: Vector3D;
        Center?: Vector3D;
    }
    export declare class BoundsInfo {
        LowX: number;
        LowY: number;
        LowZ: number;
        HighX: number;
        HighY: number;
        HighZ: number;
    }
    export declare class ObjectColors {
        Current: {
            [id: string]: string;
        };
        Default: {
            [id: string]: string;
        };
    }
    export declare class Color {
        R: number;
        G: number;
        B: number;
        Alpha: number;
    }
    export declare class ClippingPlane {
        Near: number;
        Far: number;
    }
    export declare class Instance {
        Position: Vector3D;
        Scale: Vector3D;
        Rotation: Vector3D;
    }
    export declare class ModelInfo {
        Uri: string;
        AvailableAttributes: string[];
        AvailableAspects: string[];
    }
    export declare class ProjectInfo {
        ConversionDateUtc: string;
        ExpirationDateUtc: string;
        MinimumSupportedMajorVersion: number;
        MaximumSupportedMajorVersion: number;
    }
    export declare class SnapInfo {
        Points: Vector3D[];
        Edges: Vector3D[][];
        Circles: SnapCircle[];
    }
    export declare class SnapCircle {
        Center: Vector3D;
        Radius: number;
        Normal: Vector3D;
    }
    export declare class TakeScreenshot {
        ImageData: number[];
    }
    export declare class FilesTreeObject {
        Name: string;
        Id: number;
        Type: FeatureTypes;
    }
    export declare class ChangeSet {
        Changes: ChangeSetLine[];
    }
    export declare class ChangeSetLine {
        Id: number;
        SourceValue: string;
        CustomValue: string;
        User: string;
        Timestamp: string;
        IsSessionChange: boolean;
    }
    export declare class ExportCustomAttributes {
        Changes: Change[];
    }
    export declare class Change extends ChangeSetLine {
    }
    export declare class Definition {
        Name: string;
        Mode: CustomAttributeDataType;
        Parameter1: string;
        Parameter2: string;
        Parameter3: string;
        ReadOnly: boolean;
        SourceDefinitions: CustomAttributeSourceDefinition[];
    }
    export declare class CustomAttributeSourceDefinition {
        Id: number;
        SourceAttribute: string;
        Filter: string;
        DefaultValue: string;
    }
    export declare class IntelliPidDrawingInfo {
        Identifier: string;
        IsOpen: boolean;
        IsFocused: boolean;
    }
    export declare class AttributeTreeNode {
        Id: string;
        Name: string;
        Type: string;
    }
    export declare class Quaternion {
        X: number;
        Y: number;
        Z: number;
        W: number;
        constructor(X: number, Y: number, Z: number, W: number);
        static fromEuler(value: Vector3D): Quaternion;
    }
    export declare class ProjectionSphere {
        Guid: string;
        Name: string;
        Position: Vector3D;
        Rotation: Vector3D;
        Type: ProjectionSphereType;
    }
    export declare class ParameterBase {
        ClippingFilter?: ClippingDescriptor;
        DrawLine?: DrawLineParameter;
        PlaceText?: PlaceTextParameter;
        PlaceArc?: PlaceArcParameter;
        PlacePly?: PlacePlyParameter;
        PlaceObj?: PlaceObjParameter;
        PlacePoi?: PlacePoiParameter;
        PlacePoIWithComment?: PoIWithCommentParameter;
        ImportCustomAttributeChangeSet?: ImportCustomAttributeChangeSetParameter;
        SetCustomAttributeConfiguration?: SetCustomAttributeConfigParameter;
        ExportCustomAttributes?: ExportCustomAttributesParameter;
        LoadCustomAttributeConfiguration?: LoadCustomAttributeConfigurationFileParameter;
        LoadCustomAttributeDataFile?: LoadCustomAttributeDataFileParameter;
        IntelliPidDrawingFilter?: string[];
        ProcessFile?: ProcessFileParameter;
        FilesTreeImportContainer?: FilesTreeImportContainerParameter;
        PackageFilter?: PackageFilterParameter;
    }
    export declare class ClippingDescriptor {
        Mode: ClippingMode;
        VolumeClipping?: VolumeClippingDescriptor;
        IntelliClipping?: IntelliClippingDescriptor;
    }
    export declare class VolumeClippingDescriptor {
        Bounds: Bounds;
    }
    export declare class IntelliClippingDescriptor {
        Elements: string[];
        Offset?: number;
    }
    export declare class DrawLineParameter {
        DrawingId: string;
        Vertices: Vector3D[];
        Width: number;
        Color: Color;
    }
    export declare class PlaceTextParameter {
        DrawingId: string;
        Position: Vector3D;
        EulerRotation: Vector3D;
        Text: string;
        Color: Color;
        Size: number;
        TestMode: boolean;
    }
    export declare class PlaceArcParameter {
        DrawingId: string;
        Position: Vector3D;
        EulerRotation: Vector3D;
        Color: Color;
        Angle: number;
        Radius: number;
    }
    export declare class PlacePlyParameter {
        DrawingId: string;
        Vertices: Vector3D[];
        Color: Color;
    }
    export declare class PlaceObjParameter {
        DrawingId: string;
        Instances: Instance[];
        ObjLocalPath: string;
        SuppressLoadingScreen: boolean;
    }
    export declare class PlacePoiParameter {
        Name: string;
        Position: Vector3D;
        Rotation: Vector3D;
        Links: Link[];
        Attributes: AttributePoi[];
        FilePath: string;
        Color: Color;
        Diameter: number;
        Type: PointOfInterestType;
        ParentId: number;
    }
    export declare class PoIWithCommentParameter extends PlacePoiParameter {
        Text: string;
        Offset: number;
    }
    export declare class Link {
        Name: string;
        Url: string;
    }
    export declare class AttributePoi {
        Key: string;
        Value: string;
    }
    export declare class LoadCustomAttributeConfigurationFileParameter {
        ContentBase64: string;
    }
    export declare class LoadCustomAttributeDataFileParameter {
        ContentBase64: string;
    }
    export declare class ImportCustomAttributeChangeSetParameter {
        ChangeSet: ChangeSet;
        ShowLoadScreen: boolean;
    }
    export declare class SetCustomAttributeConfigParameter {
        GeneralDefinitions: Definition[];
        UpdateMode: UpdateModes;
    }
    export declare class ExportCustomAttributesParameter {
        ExportAllAttributes: boolean;
    }
    export declare class ProcessFileParameter {
        ContentBase64: string;
    }
    export declare class FilesTreeImportContainerParameter {
        Container: ApiSerializationContainer;
        ParentId: number;
        TargetId?: number;
    }
    export declare class ApiSerializationContainer {
        Info: ApiMetadata;
        Content: string;
    }
    export declare class ApiMetadata {
        Identifier: string;
        VersionIdentifier: string;
        Name: string;
        FeatureType: FeatureTypes;
        MajorVersion: number;
        MinorVersion: number;
        ViewerVersion: string;
        CreatedDate: Date;
    }
    export declare class PackageFilterParameter {
        Package: Package;
    }
    export declare class Package {
        /** Only for fit internal Data structure */
        Name: string;
        /** Conditions. Use The Helper functions to create these */
        Conditions: PackageCondition[];
    }
    /** Please use the static Helper functions to create the Conditions */
    export declare class PackageCondition {
        Type: PackageConditionTypes;
        Parameters: any[];
        SubConditions: PackageCondition[];
        Consolidation: ConsolidationMode;
        /**
         * Create a Attribute Condition
         */
        static createAttributeCondition(mode: ConsolidationMode, key: string, conditionComparision: AttributeConditionComparison, value: string): PackageCondition;
        /**
         * Create a Volume condition that contains a min and max folder
         */
        static createVolumeCondition(mode: ConsolidationMode, volumeMode: VolumeConditionMode, min: Vector3D, max: Vector3D): PackageCondition;
        /**
         * Create a group Conditions that contains multiple Conditions
         */
        static createGroupCondition(mode: ConsolidationMode, packageConditions: PackageCondition[]): PackageCondition;
        /**
         * Create a Intelli Group Condition that supports usage of a radius
         */
        static createIntelliGroupCondition(mode: ConsolidationMode, packageConditions: PackageCondition[], radius: number): PackageCondition;
    }
    export declare class Get<T> {
        private readonly getFunction;
        constructor(getFunction: () => Promise<T>);
        /**
         * Retrieves the value asynchronous
         * @returns
         */
        get(): Promise<T>;
    }
    declare class Set$1<T> {
        private readonly setFunction;
        constructor(setFunction: (value: T) => Promise<void>);
        /**
         * Sets the Value asynchronous
         * @param value
         * @returns
         */
        set(value: T): Promise<void>;
    }
    export declare class GetSet<T> {
        private readonly getFunction;
        private readonly setFunction;
        constructor(getFunction: () => Promise<T>, setFunction: (value: T) => Promise<void>);
        /**
         * Retrieves the value asynchronous
         * @returns
         */
        get(): Promise<T>;
        /**
         * Sets the Value asynchronous
         * @param value
         * @returns
         */
        set(value: T): Promise<void>;
    }
    declare class AttributeTreeNode$1 {
        Id: string;
        Name: string;
        Type: string;
        constructor(Id: string, Name: string, Type: string);
        /**
         * Get The Root node of the Attribute Tree
         * @returns
         */
        static getRoot(): Promise<AttributeTreeNode$1>;
        /**
         * Get the current Sub Folders for this attribute tree element
         * @returns
         */
        getSubFolders(): Promise<AttributeTreeNode$1[]>;
        /**
         * Get the Siblings for this Attribute Tree element
         * @returns
         */
        getSiblings(): Promise<AttributeTreeNode$1[]>;
        /**
         * //TODO wtf
         * @param uid
         * @returns
         */
        getTreeNodesOfFolder(uid: string): Promise<AttributeTreeNode$1[]>;
    }
    export declare class ApiResponse {
        ErrorCode: number;
        ErrorMessage: string;
        RequestId: number;
    }
    export declare class ApiResponseWithType<T> extends ApiResponse {
        ResultData: T;
        constructor();
    }
    export declare class GetObjects {
        Objects: string[];
    }
    export declare class GetSelectedObjects {
        Intellipid: Intellipid;
        SelectedObjects: string[];
    }
    export declare class Intellipid {
        DisplayName: string;
        Path: string;
    }
    export declare class GetObjectsAttributes {
        ObjectsAttributes: {
            [id: string]: {
                [key: string]: string;
            };
        };
    }
    export declare class GetObjectsBoundingBox {
        ObjectsBoundingBox: {
            [id: string]: BoundsInfo;
        };
    }
    export declare class GetObjectsColors {
        ObjectsColors: {
            [id: string]: ObjectColors;
        };
    }
    export declare class GetModelInfo {
        ModelInfo: ModelInfo;
    }
    export declare class GetClippingInfoResult {
        Clipping: ClippingDescriptor;
    }
    export declare class GetObjectsSnapInfo {
        ObjectsSnapInfo: {
            [id: string]: SnapInfo;
        };
    }
    export declare class GetCameraView {
        CameraView: CameraView;
    }
    export declare class GetProjectInfo {
        ProjectInfo: ProjectInfo;
    }
    export declare class TakeScreenshotResult {
        TakeScreenshot: TakeScreenshot;
    }
    export declare class GetFilesTreeObject {
        FilesTreeObject: FilesTreeObject;
    }
    export declare class GetFilesTreeObjects {
        FilesTreeObjects: FilesTreeObject[];
    }
    export declare class GetTreeConfiguration {
        TreeConfiguration: string[];
    }
    export declare class GetVisibleAspects {
        VisibleAspects: string[];
    }
    export declare class GetLifeCycleState {
        LifeCycleState: LifeCycleState;
    }
    export declare class LifeCycleState {
        WaitingForModelSelection: number;
        ModelFinishedLoading: number;
        CustomAttributesFinishedLoading: number;
    }
    export declare class GetCustomAttributesConfiguration {
        GetCustomAttributeConfiguration: Definition[];
    }
    export declare class ExportCustomAttributesResult {
        ExportCustomAttributes: ExportCustomAttributes;
    }
    export declare class GetIntellipidDrawings {
        GetIntelliPidDrawings: {
            [id: string]: IntelliPidDrawingInfo;
        };
    }
    export declare class GetTreeRootNode {
        GetTreeRootNode: AttributeTreeNode;
    }
    export declare class GetTreeFolderChildren {
        GetTreeFolderChildren: AttributeTreeNode[];
    }
    export declare class GetTreeFolderSiblings {
        GetTreeFolderSiblings: AttributeTreeNode[];
    }
    export declare class GetTreeNodesOfFolder {
        GetTreeNodesOfFolder: AttributeTreeNode[];
    }
    export declare class GetTreeStructure {
        GetTreeStructure: {
            [id: string]: AttributeTreeNode[];
        };
    }
    export declare class GetProjectionSpheres {
        ProjectionSpheres: ProjectionSphere[];
    }
    export declare class GetFilesTreeContainerObject {
        FilesTreeContainerObject: FilesTreeContainerObject;
    }
    export declare class FilesTreeContainerObject {
        Container: ApiSerializationContainer;
    }
    /**
     * @internal
     */
    export declare enum ApiEvents {
        SelectionChanged = "SelectionChanged",
        PointerClicked = "PointerClicked",
        LinkClicked = "LinkClicked",
        LifeCycle = "LifeCycle",
        CustomAttributeValueChanged = "CustomAttributeValueChanged",
        AnimationTimestampChanged = "AnimationTimestampChanged",
        IntellipidSelectionChanged = "IntellipidSelectionChanged"
    }
    /**
     * @internal
     */
    export declare class PointerClickedEvent {
        PointerClicked: PointerClicked;
    }
    /**
     * @internal
     */
    export declare class SelectionChangedEvent {
        SelectionChanged: SelectionChanged;
    }
    /**
     * @internal
     */
    export declare class LinkClickedEvent {
        LinkClicked: LinkClicked;
    }
    /**
     * @internal
     */
    export declare class CustomAttributeValueChangedEvent {
        CustomAttributeValueChanged: CustomAttributeValueChanged;
    }
    /**
     * @internal
     */
    export declare class AnimationTimestampChangedEvent {
        AnimationTimestampChanged: AnimationTimestampChangedObject;
    }
    export declare class CustomAttributeValueChanged {
    }
    export declare class PointerClicked {
        Button: string;
        X: number;
        Y: number;
        ModelPosition?: Vector3D;
    }
    export declare class SelectionChanged {
        Objects: string[];
    }
    export declare class LifeCycleEvent {
        LifeCycle: string;
        Source: TargetEnum;
    }
    export declare class LinkClicked {
        Url: string;
        Template: string;
        AssociatedObject: string;
    }
    export declare class AnimationTimestampChangedObject {
        Timestamp: AnimationTimestamp;
    }
    export declare class AnimationTimestamp {
        Start: string;
        End: string;
        Current: string;
        IsPlaying: boolean;
    }
    export declare class IntellipidSelectionChangedEvent {
        IntellipidSelectionChanged: IntellipidSelectionChanged;
    }
    export declare class IntellipidSelectionChanged {
        Intellipid: Intellipid;
        Objects: string[];
    }
    declare class CaxApiCommand {
        requestId: number;
        additionalParameters: ParameterBase;
        command: ApiCommands;
        commandParameters: string[];
        condition: string;
        conditionCombineMode: CombineModes;
        model: string;
        target: string;
        constructor(command: ApiCommands);
        test(): void;
    }
    /**
     * Basesclass of all Scenes
     */
    export declare abstract class Scene {
        Id: string;
        constructor(Id: string);
        /**
         * Describes what type a scene is
         */
        SceneType: SceneType;
        /**
         * Load a colorfile via a file
         * @param file path to excel colorfile
         * @returns ApiResponse can be ignored and will likely change
         */
        loadColorFile(file: string): Promise<ApiResponse>;
        /**
         * Load a linkfile via a file
         * @param file path to excel linkfile
         * @returns ApiResponse can be ignored and will likely change
         */
        loadLinkFile(file: string): Promise<ApiResponse>;
        /**
         * Clears all Links
         * @returns ApiResponse can be ignored and will likely change
         */
        clearLinks(): Promise<ApiResponse>;
        /**
         * Take a screenshot
         * @param width Width of the output picture
         * @param height Height of the output picture
         * @param fieldOfView Field of View
         * @param hideUi Draw UI in picture
         * @param enableAntiAliasing Use AntiAliasing
         * @param enableTransparentBackground Draws the brackground transparent (only SHows the model)
         * @param modelInBestQuality Take the screenshot of the model in the best quality
         * @returns
         */
        takeScreenshot(width?: number, height?: number, fieldOfView?: number, hideUi?: boolean, enableAntiAliasing?: boolean, enableTransparentBackground?: boolean, modelInBestQuality?: boolean): ScreenShot;
        /**
         * @internal
         */
        createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    /**
     * 3D Scene
     */
    export declare class Scene3d extends Scene {
        constructor(id: string);
        /**
         * The UI Cliping descriptor currently active
         */
        UiClippingDescriptor: GetSet<ClippingDescriptor>;
        /**
         * The default filter available
         * More filters can be created using {@link getNewFilter}
         */
        DefaultFilter: FilterOperation3d;
        /**
         * The Camera object for this scene
         */
        Camera: Camera;
        /**
             * The current Tree Configuration of this scene
             * This might move
             */
        TreeConfiguration: GetSet<string[]>;
        /**
         * Defines what aspects are currently visible
         */
        VisibleAspects: GetSet<string[]>;
        /**
         * Create a new Filteropration
         * @returns FilterOperation3d
         */
        getNewFilter(): FilterOperation3d;
        private intelliClip;
        private volumeClipByCoordinates;
    }
    /**
     * 2D Scene
     */
    export declare class ScenePid extends Scene {
        constructor(id: string);
        /**
         * the default filter that can be used. New Filters can be created using {@link getNewFilter}
         */
        DefaultFilter: FilterOperationPid;
        /**
         * Create a new Filteropration
         * @returns FilterOperationPid
         */
        getNewFilter(): FilterOperationPid;
    }
    /**
     * Provides control over a AppControl Scene
     * @alpha
     */
    export declare class AppControlScene extends Scene {
        /**
         * @internal
         * @param id
         */
        constructor(id: string);
    }
    declare abstract class FilterOperation {
        protected readonly scene: Scene;
        constructor(scene: Scene);
        /**
         * The Condition used in the filter
         */
        Condition?: string;
        /**
         * How the {@link Condition} is evaluated
         */
        CombineMode: CombineModes;
        /**
         * Should objects returned by GetObjects include Attributes
         */
        IncludeAttributes: boolean;
        /**
         * if empty all attributes will be retrieved else only the specified. Requires {@link IncludeAttributes}
         */
        Attributes: string[];
        /**
         * Should objects returned by GetObjects include CustomAttribute Information
         */
        IncludeCustomAttributes: boolean;
        abstract getObjects(): Promise<ModelObject[]>;
        /**
         * Get all Attributes that are currently selected
         * @returns
         */
        getSelectedObjects(): Promise<ModelObject[]>;
        /**
         * Select all objects hit by this FilterOperation
         * @returns
         */
        select(): Promise<ApiResponse>;
        /**
         * Clear the current selection
         * @returns
         */
        clearSelection(): Promise<ApiResponse>;
        /**
         * Fit all objects hit by this FilterOperation
         * @returns
         */
        fit(): Promise<ApiResponse>;
        /**
         * color all objects hit by this Fileroperation with the specified color
         * @param color hex color
         * @returns
         */
        color(color: string): Promise<ApiResponse>;
        /**
         * Reset the color of all objects hit by this FilterOperation
         * @returns
         */
        clearColor(): Promise<ApiResponse>;
        /**
         * input the {@link Condition} into the search field inside UPV
         * @returns
         */
        searchFallback(): Promise<ApiResponse>;
        /**
         * @internal
         * @param apiCommands
         * @returns
         */
        abstract createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    export declare class FilterOperation3d extends FilterOperation {
        constructor(scene: Scene);
        /**
         * Should objects returned by GetObjects include the boundingbox
         */
        IncludeBoundingBox: boolean;
        /**
         * Should objects returned by GetObjects include Colors
         */
        IncludeColors: boolean;
        /**
         * Should objects returned by GetObjects include SnapInfo
         */
        IncludeSnapInfo: boolean;
        /**
         * Advanced API Clipping
         */
        ApiClippingDescriptor?: ClippingDescriptor;
        /**
         * Advanced API Filtering using the Package Logic
         * used to create more advanced posibilities then {@link Condition} and {@link CombineMode}
         * The Condition property is still evaluated. So its best to use a match all query like Uid=*
         */
        APIPackageFilter?: Package;
        /**
         * All objects based on the attributes specified in the FilterOperation
         */
        getObjects(): Promise<ModelObject[]>;
        /**
         * Highlights all Elements hit by FilterOperation
         * @returns
         */
        highlight(): Promise<ApiResponse>;
        /**
         * Clears any active hightlighting
         * @returns
         */
        clearHighlight(): Promise<ApiResponse>;
        /**
         * Show only objects hit by the FilterOpration
         * @returns
         */
        showOnly(): Promise<ApiResponse>;
        /**
         * Set the Visibility of all objects hit by this Filteropration
         * @param state new state (show/true, hide/false)
         * @returns
         */
        setVisibility(state: boolean): Promise<ApiResponse>;
        /**
         * activate a volumeClip Operation around objects hit by this Filteroperation
         * @param radius
         * @returns
         */
        volumeClip(radius: number): Promise<ApiResponse>;
        getTreeStructure(condition: string): Promise<{
            [id: string]: AttributeTreeNode$1[];
        }>;
        /**
         * @internal
         * @param apiCommands
         * @returns
         */
        createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    /**
     * Fileropration Special for IntelliPID
     */
    export declare class FilterOperationPid extends FilterOperation {
        constructor(scene: Scene);
        /**
         * DrawingFilter to use. Can be an array of the Pids or/and UPVCurrent (Currently active PID) or UPVAllOpen (All open Pids. Also in Background).
         */
        DrawingFilter?: string[] | "UPVCurrent"[] | "UPVAllOpen"[];
        getObjects(): Promise<ModelObject[]>;
        /**
         * @internal
         * @param apiCommands
         * @returns
         */
        createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    export declare class ModelObject {
        constructor(uid: string);
        /**
         * @internal
         * @param attributes
         * @param bounds
         * @param objectColors
         * @param snapInfo
         */
        init(attributes?: Attribute[], bounds?: BoundsInfo, objectColors?: ObjectColors, snapInfo?: SnapInfo): void;
        /**
         * Get the Attribute value. This is shortcut for get an attribute instead of using the {@link Attributes} attributes array
         * @param name attribute name
         * @returns value or null if not found
         */
        getAttribute(name: string): string;
        /**
         * Set a Custom Attribute. This is shortcut for get an attribute instead of using the {@link Attributes} attributes array
         * @param name attribute name
         * @param value new attribute value
         * @param user username of the person changing the attribute
         * @returns
         */
        setCustomAttribute(name: string, value: string, user: string): Promise<any>;
        /**
         * Uid of the object
         */
        Uid: string;
        /**
         * Attributes of the object
         */
        Attributes?: Attribute[];
        /**
         * Bounds of the object
         */
        Bounds?: BoundsInfo;
        /**
         * Snapinfo of the object
         */
        SnapInfo?: SnapInfo;
        /**
         * the current colors of the object
         */
        ObjectColors?: ObjectColors;
    }
    export declare class Attribute {
        private readonly uid;
        key: string;
        value: string;
        /**
         * The value of the attribute
         */
        Value: string;
        /**
         * The key of the attribute
         */
        Key: string;
        /**
         * The key of the attribute
         */
        IsCustomAttribute: boolean;
        /**
         * Update the Custom Attribute. First parameter is the new value. second is the username of the person updating
         */
        SetCustomAttribute: Set$1<{
            value: string;
            user: string;
        }>;
        constructor(uid: string, key: string, value: string, isCustomAttribute: boolean, customAttributeDefinition: Definition, customAttributeSourceValue: string);
    }
    /** Contains the file variants. These might be made unavailable in future versions and replaced by new commands*/
    export declare class CustomAttributeLegacy {
        private customAttributes;
        constructor(customAttributes: CustomAttributes);
        loadCustomAttributeConfigurationFile(file: string): Promise<ApiResponse>;
        loadCustomAttributeDataFile(file: string): Promise<ApiResponse>;
    }
    export declare class CustomAttributes {
        private model;
        constructor(model: Model);
        get legacy(): CustomAttributeLegacy;
        clearCustomAttributes(): Promise<ApiResponse>;
        loadCustomAttributeConfigurationBase64(contentBase64: string): Promise<ApiResponse>;
        loadCustomAttributeDataBase64(contentBase64: string): Promise<ApiResponse>;
        importCustomAttributeChangeSet(changeSets: ChangeSetLine[], showLoadScreen: boolean): Promise<ApiResponse>;
        setCustomAttributeConfiguration(definitions: Definition[], updateMode: UpdateModes): Promise<ApiResponse>;
        getCustomAttributeConfiguration(): Promise<Definition[]>;
        exportCustomAttributes(exportAll: boolean): Promise<ExportCustomAttributes>;
        createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    export declare class Camera {
        private scene;
        /**
         * Access to the cameras position
         */
        Position: GetSet<Vector3D>;
        /**
         * Access to the cameras rotation
         */
        Rotation: GetSet<Vector3D>;
        /**
         * Access to the cameras position and rotation combined (faster)
         */
        CameraView: GetSet<CameraView>;
        /**
         * Access to the cameras position and rotation combined (faster)
         */
        ClippingPlane: GetSet<ClippingPlane>;
        /**
         * @internal
         * @param scene
         */
        constructor(scene: Scene3d);
        private setCameraView;
        private getCameraView;
        private getClippingPlane;
        private setClippingPlane;
        /**
         * Make the camera look at a target from the current view
         * @param target Vector of the target
         * @returns
         */
        lookAt(target: Vector3D): Promise<ApiResponse>;
        /**
         * Reset the view to the default position
         * @returns
         */
        resetView(): Promise<ApiResponse>;
    }
    export declare class Layer {
        GroupId: string;
        constructor(GroupId: string);
        /**
         * Place an OBJ in the scene
         * @param obj Path to the obj file
         * @param instances The Instances of this object
         * @param suppressLoadingScreen
         */
        placeObj(obj: string, instances: Instance[], suppressLoadingScreen?: boolean): Promise<void>;
        /**
         * Draw a Line in 3D
         * @param vertices Points of the line
         * @param color The color of the line
         * @param width THe Width of the line
         */
        drawLine(vertices: Vector3D[], color: Color, width: number): Promise<void>;
        /**
         * Place a text inside a 3d scene
         * @param text The text to draw
         * @param position The position of the text
         * @param rotation The rotation of the text
         * @param size The size of the text
         * @param color The color of the tex
         * @param testMode Dont actually place the text
         */
        placeText(text: string, position: Vector3D, rotation: Vector3D, size: number, color: Color): Promise<void>;
        /**
         * Place an arc
         * @param position Position of the arc
         * @param rotation Rotation of the arc
         * @param color Color of the arc
         * @param angle Angle of the arc
         * @param radius Radius of the arc
         */
        placeArc(position: Vector3D, rotation: Vector3D, color: Color, angle: number, radius: number): Promise<void>;
        /**
         * Place a PLY mesh
         * @param color Color of the Mesh
         * @param vertices Every 3 vertecies build a face
         */
        placePly(color: Color, vertices: Vector3D[]): Promise<void>;
        /**
         * Destroy the active drawing
         */
        destroy(): Promise<void>;
        /**
         * @internal
         */
        private createCommand;
    }
    export declare class Model {
        Id: string;
        Scenes: Scene[];
        ModelInfo: Get<ModelInfo>;
        ProjectInfo: Get<ProjectInfo>;
        /**
         * Current Porjections inside the model. 360 Panoramas and mapped imanges
         */
        Projections: Get<ProjectionSphereElement[]>;
        /**
         * Currently open projection. the Get result is null if currently not inside a projection.
         */
        CurrentProjection: Get<ProjectionSphereElement>;
        /**
         * Access Custom Attributes
         */
        get CustomAttributes(): CustomAttributes;
        constructor(Id: string);
        loadConfigFile(file: string): Promise<ApiResponse>;
        getIntelliPidDrawings(condition: string, combineMode: CombineModes): Promise<IntelliPidDrawing[]>;
        openIntelliPidDrawings(condition: string, combineMode: CombineModes, drawingFilter?: string[]): Promise<ApiResponse>;
        /**
         * @internal
         * @param apiCommands
         * @returns
         */
        createCommand(apiCommands: ApiCommands): CaxApiCommand;
    }
    export declare class IntelliPidDrawing {
        private readonly info;
        private readonly model;
        Identifier: string;
        IsOpen: boolean;
        IsFocused: boolean;
        constructor(info: IntelliPidDrawingInfo, model: Model);
        /**
         * Open the IntelliPidDrawing
         * @returns
         */
        openIntelliPidDrawings(): Promise<ApiResponse>;
    }
    export declare class ScreenShot {
        private readonly Scene;
        private readonly Width;
        private readonly Height;
        private readonly FieldOfView;
        private readonly HideUi;
        private readonly EnableAntiAliasing;
        private readonly EnableTransparentBackground;
        private readonly ModelInBestQuality;
        constructor(Scene: Scene, Width: number, Height: number, FieldOfView: number, HideUi: boolean, EnableAntiAliasing: boolean, EnableTransparentBackground: boolean, ModelInBestQuality: boolean);
        /**
         * Save Screenshot to file
         * @param path
         * @param format
         * @returns
         */
        saveToFile(path: string, format: string): Promise<ApiResponse>;
        /**
         * retrieves the bytes of the screenshot
         * @param format
         * @returns
         */
        returnAsBytes(format: string): Promise<ApiResponseWithType<TakeScreenshotResult>>;
    }
    export declare class Events {
        private unloaded;
        private registeredEvents;
        constructor();
        private onUnload;
        /**
         * Register Selection Changed Event
         */
        registerSelectionChangedEvent(callback: (data: SelectionChanged) => void): Promise<number>;
        /**
         * Register Pointer Clicked Event
         */
        registerPointerClickedEventEvent(callback: (data: PointerClicked) => void): Promise<number>;
        /**
         * Register Lifecycle Event
         */
        registerLifeCycleEvent(callback: (data: LifeCycleEvent) => void): Promise<number>;
        /**
         * Register Link Clicked Event
         */
        registerLinkClickedEvent(callback: (data: LinkClicked) => void): Promise<number>;
        /**
         * Register CUstom Attribute Changed Event
         */
        registerCustomAttributeValueChangedEvent(callback: (data: CustomAttributeValueChanged) => void): Promise<number>;
        /**
         * Register Animation Timestamp Changed Event
         */
        registerAnimationTimestampChangedEvent(callback: (data: AnimationTimestampChangedObject) => void): Promise<number>;
        /**
         * Register Selection Changed Event for IntelliPid
         */
        registerIntellipidSelectionChangedEvent(callback: (data: IntellipidSelectionChanged) => void): Promise<number>;
        /**
         * Use this function in react useEffect functions to automatically provide the unregister function
         * @param fun the event function that should be called
         * @param callback the callback function that this event should excute
         * @returns the unregister event function
         */
        useEffectWrapper<T>(fun: (callback: (data: T) => void) => Promise<number>, callback: (data: T) => void): () => void;
        /**
         * remove any event with that ID
         */
        removeEvent(id: number): Promise<void>;
    }
    export declare class ProjectionSphereElement {
        readonly projectionSphere: ProjectionSphere;
        private readonly model;
        constructor(projectionSphere: ProjectionSphere, model: Model);
        /**
         * Enter the Projection
         * @param opacity optional, is set overwrite the opacity value with the new value
         * @param rotation optional, enter a rotation to view the projection from
         * @returns
         */
        EnterProjectionSphere(opacity?: number, rotation?: Vector3D): Promise<ApiResponse>;
        /**
         * Leave the current Projection
         * @returns
         */
        LeaveProjectionSphere(): Promise<ApiResponse>;
    }
    export declare class FileTreeElement {
        private readonly _id;
        private _name;
        private _type;
        /**
         * get the id of the File Tree Element
         */
        get Id(): number;
        /**
         * get the name of the File Tree Element
         */
        get Name(): string;
        /**
         * get the type of the File Tree Element
         */
        get Type(): FeatureTypes;
        /**
         * @internal
         * @param _id
         * @param _name
         * @param _type
         */
        protected constructor(_id: number, _name: string, _type: FeatureTypes);
        /**
         * Delete File tree element
         */
        delete(): Promise<void>;
        /**
         * This functions exposes the internal datastructure. THis is only intended for special usecases
         * No documentation is available/will be made available for these internal structures
         * @returns
         */
        getContent(): Promise<GetFilesTreeContainerObject>;
    }
    export declare class FileTreeAnimation extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeAppControl extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeComment extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeFolder extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeMarkup extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeModel extends FileTreeFolder {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreePackage extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreePhoto extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreePIDSketch extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreePointOfInterest extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeReport extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeScreenshot extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeSketch extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeTwoDToThreeD extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeView extends FileTreeElement {
        constructor(id: number, name: string, type: FeatureTypes);
    }
    export declare class FileTreeManager {
        /**
         * Returns the root folder in the UPV filetree
         * @returns
         */
        getRootFolder(): Promise<FileTreeModel>;
        /**
         * Get the children Elements of this File Tree Elements
         */
        getChildren(folder: FileTreeFolder): Promise<FileTreeElement[]>;
        /**
         * Get the sibelings Elements of this File Tree Elements
         */
        getSiblings(element: FileTreeElement): Promise<FileTreeElement[]>;
        /**
         * Move a file Tree Element into a diffrent folder
         */
        moveTo(source: FileTreeElement, target: FileTreeFolder): Promise<void>;
        /**
         * This function allows you to import any filetree element.
         * This is not designed for normal usage and requires extensive knowledge.
         * FileTreeElement.getContent can be used to retrieve the data
         * Since the content of filetree element are internal datastructures no support is/will be made available
         * @param parameter
         */
        importContainer(parameter: FilesTreeImportContainerParameter): Promise<FileTreeElement>;
        createFolder(parent: FileTreeFolder, name: string): Promise<FileTreeFolder>;
        createPointOfIntrest(parameter: PlacePoiParameter, folder: FileTreeFolder): Promise<FileTreePointOfInterest>;
        createPointOfIntrestWithComment(parameter: PoIWithCommentParameter, folder: FileTreeFolder): Promise<FileTreeElement[]>;
        private resolveElement;
    }
    /**
     * @class Application
     * Main Entrypoint for interacting with the UPV API
     */
    export declare class Application {
        /**
         * Contains all Scenes in the running UPV Instance. To Filter for specific scenes individual properties exist. Example @see{@link ScenePid}
         */
        Scenes: Get<Scene[]>;
        /**
         * Contains all IntelliPid scenes
         */
        ScenesPid: Get<ScenePid[]>;
        /**
         * Contains all 3D scenes
         */
        Scenes3d: Get<Scene3d[]>;
        /**
         * Contains all app control scenes
         */
        ScenesAppControls: Get<AppControlScene[]>;
        /**
         * Contains all model loaded inside UPV
         */
        Models: Get<Model[]>;
        /**
         * The current Live Cycle State of UPV
         */
        State: Get<LifeCycleState>;
        /**
         * Handles all type of events for UPV
         */
        Events: Events;
        /**
         * Handles all type of events for UPV
         */
        FileTree: FileTreeManager;
        /**
         *
         * @private
         *
         */
        private constructor();
        /**
         * Create an instance of this class
         * @returns {@link Application}
         */
        static getInstance(): Application;
        /**
         * Opens a popup with a message inside UPV
         * @param message Message to display
         * @returns ApiResponse can be ignored and will likely change
         */
        showMessage(message: string): Promise<ApiResponse>;
        /**
         * Focus the viewer into the foreground
         * @returns ApiResponse can be ignored and will likely change
         */
        focusViewer(): Promise<ApiResponse>;
        /**
         * Closes UPV
         * @returns ApiResponse can be ignored and will likely change
         */
        quitApplication(): Promise<ApiResponse>;
        /**
         * Load the model into UPV
         * @param modelUri path to model
         * @returns ApiResponse can be ignored and will likely change
         */
        loadModel(modelUri: string): Promise<ApiResponse>;
        /**
         * Caches a UPV Model
         * @param modelUri path to model
         * @returns ApiResponse can be ignored and will likely change
         */
        cacheModel(modelUri: string): Promise<ApiResponse>;
        /**
         * Activate a license key
         * @param license licensekey to activate
         * @returns ApiResponse can be ignored and will likely change
         */
        activateLicense(license: string): Promise<ApiResponse>;
        /**
         *
         * @returns Deactivate an active license
         * @returns ApiResponse can be ignored and will likely change
         */
        deactivateLicense(): Promise<ApiResponse>;
        loadFile(path: string): Promise<ApiResponse>;
        /**
         * Load UPVF file from a bytearray
         * @param processFile
         * @returns
         */
        processFile(processFile: ProcessFileParameter): Promise<ApiResponse>;
        /**
         * @legacy
         * @param path
         * @returns
         */
        loadSketch(path: string, viewName?: string): Promise<ApiResponse>;
        /**
         * @legacy
         * @param path
         * @returns
         */
        loadPackageFile(path: string, replace?: boolean): Promise<ApiResponse>;
        /**
         * @legacy
         * @param path
         * @returns
         */
        exportPackageFile(path: string): Promise<ApiResponse>;
        /**
         * Set an Authentication config used when opening models
         * @param domainUri for which URI is the config valid
         * @param configUri the configuration to use
         * @returns ApiResponse can be ignored and will likely change
         */
        setAuthConfig(domainUri: string, configUri: string): Promise<ApiResponse>;
        /**
         * Clear an authentication config for a URI
         * @param domainUri the URI to delete an authentication config for
         * @returns ApiResponse can be ignored and will likely change
         */
        clearAuthConfig(domainUri: string): Promise<ApiResponse>;
        /**
         * Open a path on the local system
         * @param path path to open using the system default example https://google.com
         * @returns
         */
        openPath(path: string): Promise<ApiResponse>;
        /**
         * Checks if a connection to UPV is available and commands can be send to UPV
         * @returns
         */
        available(): boolean;
    }
    /**
     * Defines the Material UI Theme
     */
    export declare class Theme {
        /**
         * Provides @mui/material/styles/ThemeOptions for use in AppControls. To not add Material UI as a requirement any type is returned here
         * It is safe to cast this to ThemeOptions in your code or directly provide it to createTheme function
        */
        static getTheme(): Promise<any>;
    }

    export {
        Set$1 as Set,
    };

    export { };
}